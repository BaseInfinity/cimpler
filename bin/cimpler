#!/usr/bin/env node

var net        = require('net'),
util           = require('util'),
fs             = require('fs'),
childProcess   = require('child_process'),
tcpTrigger     = require('../lib/tcp-trigger'),
error          = (util.error || console.log),
execOptions    = {},
build          = {},
args           = require('optimist')
   .demand(1)
   .usage("Usage: cimpler test [-b branch-name]")
   .options('branch', {
      alias: 'b',
      describe: 'Name of the branch to test (defaults to current)'
   })
   .options('port', {
      alias: 'p',
      describe: 'TCP port of the cimpler server (defaults to value in config.js)'
   }).argv;


exec("git remote -v", function(stdout) {
   // Output looks like:
   // origin  http://remote_url (fetch)
   // ...
   var remotes = stdout.split("\n");
   // Default to the first remote.
   var originRemote = remotes[0];
   // Choose the first remote containing ^origin
   for(var i=0; i<remotes.length; i++) {
      if (remotes[i].match(/^origin\s/)){
         originRemote = remotes[i];
         break;
      }
   }
   // If we found a remote
   if (originRemote) {
      build.repo = originRemote.split(/\s+/)[1];
      getBranch();
   } else {
      exec("git rev-parse --show-toplevel", function(stdout) {
         // Output looks like:
         // /usr/blah/path/to/repo
         build.repo = stdout.trim();
         getBranch();
      });
   }
});

function getBranch() {
   if (args.branch) {
      build.branch = args.branch;
      tcpTrigger(build, args.port);
   }

   exec("git symbolic-ref HEAD", function(stdout) {
      // output == "refs/heads/branch"
      build.branch = stdout.trim().split('/').pop();
      tcpTrigger(build, args.port);
   });
}

function exec(cmd, callback) {
   childProcess.exec(cmd, execOptions, function(err, stdout) {
      if (err) {
         error("Command failed: " + cmd);
         error(err.toString());
         process.exit(1);
      }
      callback(stdout.toString());
   });
}

