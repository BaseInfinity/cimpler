#!/usr/bin/env node

var net        = require('net'),
util           = require('util'),
fs             = require('fs'),
childProcess   = require('child_process'),
error          = (util.error || console.log),
execOptions    = {},
defaultTcpPort = 20001,
build          = {},
args           = require('optimist')
   .demand(1)
   .usage("Usage: cimpler test [-b branch-name]")
   .options('branch', {
      alias: 'b',
      describe: 'Name of the branch to test (defaults to current)'
   })
   .options('port', {
      alias: 'p',
      describe: 'TCP port of the cimpler server (defaults to value in config.js)'
   }).argv;


var plugins;
var tcpPort = args.port ||
              ((plugins = loadConfig(__dirname + '/../config.js').plugins) &&
               plugins.cli &&
               plugins.cli.tcpPort) ||
              defaultTcpPort;

exec("git remote -v", function(stdout) {
   // Output looks like:
   // origin  http://remote_url (fetch)
   // ...
   var remotes = stdout.split("\n");
   // Default to the first remote.
   var originRemote = remotes[0];
   // Choose the first remote containing ^origin
   for(var i=0; i<remotes.length; i++) {
      if (remotes[i].match(/^origin\s/)){
         originRemote = remotes[i];
         break;
      }
   }
   // If we found a remote
   if (originRemote) {
      build.repo = originRemote.split(/\s+/)[1];
      getBranch();
   } else {
      exec("git rev-parse --show-toplevel", function(stdout) {
         // Output looks like:
         // /usr/blah/path/to/repo
         build.repo = stdout.trim();
         getBranch();
      });
   }
});

function getBranch() {
   if (args.branch) {
      build.branch = args.branch;
      return triggerBuild();
   }

   exec("git symbolic-ref HEAD", function(stdout) {
      // output == "refs/heads/branch"
      build.branch = stdout.trim().split('/').pop();
      triggerBuild();
   });
}

function triggerBuild() {
   process.stdout.write("Triggering build on " + build.branch + " ... ");
   var connection = net.createConnection(tcpPort, "127.0.0.1", function() {
      connection.end(JSON.stringify(build));
   });

   var body = '';
   connection.setEncoding('utf8');
   connection.on('data', function(chunk) {
      body += chunk;
   });

   connection.on('end', function() {
      if (body) {
         console.log(body);
      }

      if (body !== 'OK') {
         process.exit(1);
      }
   });

   connection.on('error', function() {
      console.log("Couldn't connect to cimpler server");
      process.exit(1);
   });
}

function exec(cmd, callback) {
   childProcess.exec(cmd, execOptions, function(err, stdout) {
      if (err) {
         error("Command failed: " + cmd);
         error(err.toString());
         process.exit(1);
      }
      callback(stdout.toString());
   });
}


function loadConfig(path) {
   try {
      if (fs.statSync(path)) {
         return require(path);
      }
   } catch (err) {}
   return {};
}
